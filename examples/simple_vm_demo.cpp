/**
 * Simple Madrona VM Demo Application
 * 
 * This demonstrates the complete end-to-end pipeline:
 * 1. Load simple_patch.json
 * 2. Parse JSON into PatchGraph
 * 3. Compile PatchGraph to bytecode
 * 4. Load bytecode into VM
 * 5. Process audio blocks
 * 
 * This is the reference implementation for VM_DESIGN.md Step 6.
 */
#include "parser/parser.h"
#include "compiler/compiler.h"
#include "compiler/module_registry.h"
#include "vm/vm.h"
#include "vm/opcodes.h"
#include "dsp/audio_out.h"
#include "ui/device_selector.h"
#include "audio/device_info.h"
#include <iostream>
#include <fstream>
#include <chrono>
#include <iomanip>
#include <string>
#include <thread>
#ifndef MODULE_DEFS_PATH
#define MODULE_DEFS_PATH "data/modules.json"
#endif
using namespace madronavm;
int main(int argc, char* argv[]) {
  try {
    std::cout << "=== Madrona VM Demo Application ===" << std::endl;
    std::cout << "Demonstrating end-to-end patch processing pipeline\n" << std::endl;
    // === STEP 1: Load patch file ===
    std::string patch_path = (argc > 1) ? argv[1] : "examples/simple_patch.json";
    std::cout << "Step 1: Loading patch file: " << patch_path << std::endl;
    std::ifstream patch_file(patch_path);
    if (!patch_file.is_open()) {
      std::cerr << "Error: Could not open patch file: " << patch_path << std::endl;
      return 1;
    }
    std::string json_content((std::istreambuf_iterator<char>(patch_file)),
                           std::istreambuf_iterator<char>());
    patch_file.close();
    std::cout << "  ✓ Loaded " << json_content.size() << " bytes from patch file\n" << std::endl;
    // === STEP 2: Parse JSON into PatchGraph ===
    std::cout << "Step 2: Parsing JSON into PatchGraph..." << std::endl;
    auto graph = madronavm::parse_json(json_content);
    std::cout << "  ✓ Parsed graph with:" << std::endl;
    std::cout << "    - " << graph.nodes.size() << " nodes" << std::endl;
    std::cout << "    - " << graph.connections.size() << " connections" << std::endl;
    // Display node details
    for (const auto& node : graph.nodes) {
      std::cout << "    - Node " << node.id << ": " << node.name;
      if (!node.constants.empty()) {
        std::cout << " (constants: ";
        for (size_t i = 0; i < node.constants.size(); ++i) {
          if (i > 0) std::cout << ", ";
          std::cout << node.constants[i].port_name << "=" << node.constants[i].value;
        }
        std::cout << ")";
      }
      std::cout << std::endl;
    }
    std::cout << std::endl;
    // === STEP 3: Compile to bytecode ===
    std::cout << "Step 3: Compiling PatchGraph to bytecode..." << std::endl;
    madronavm::ModuleRegistry registry(MODULE_DEFS_PATH);
    auto bytecode = madronavm::Compiler::compile(graph, registry);
    // Display bytecode info
    madronavm::BytecodeHeader header;
    std::memcpy(&header, bytecode.data(), sizeof(header));
    std::cout << "  ✓ Generated bytecode:" << std::endl;
    std::cout << "    - Total size: " << bytecode.size() << " words (" 
              << (bytecode.size() * sizeof(uint32_t)) << " bytes)" << std::endl;
    std::cout << "    - Magic number: 0x" << std::hex << header.magic_number << std::dec << std::endl;
    std::cout << "    - Version: " << header.version << std::endl;
    std::cout << "    - Registers needed: " << header.num_registers << std::endl;
    std::cout << "    - Program size: " << header.program_size_words << " words\n" << std::endl;
    // === STEP 4: Load into VM ===
    std::cout << "Step 4: Loading bytecode into VM..." << std::endl;
    madronavm::VM vm(registry, 44100.0f);
    vm.load_program(std::move(bytecode));
    std::cout << "  ✓ Bytecode successfully loaded into VM\n" << std::endl;
    // === STEP 5: Play audio ===
    std::cout << "Step 5: Playing audio for 5 seconds..." << std::endl;
    std::cout << "  (The VM will be driven by the audio callback at the correct rate)" << std::endl;
    // Create the audio driver and link it to the VM
    AudioOut audio_out_driver(44100.0f, false); // false = not test mode
    audio_out_driver.setVMCallback(
      [&vm](float** outputs, int blockSize){
        vm.processBlock(outputs, blockSize);
      }
    );
    const int play_duration_seconds = 5;
    std::cout << "  ♪ Audio started - you should hear a 440Hz sine wave" << std::endl;
    // Let the audio play - our explicit AudioOut instance will drive the VM processing
    // at the correct real-time rate via its audio callback.
    std::this_thread::sleep_for(std::chrono::seconds(play_duration_seconds));
    std::cout << "  ✓ Audio playback completed" << std::endl;
    std::cout << "\n=== End-to-End Demo Completed Successfully! ===" << std::endl;
    return 0;
  } catch (const std::exception& e) {
    std::cerr << "Error: " << e.what() << std::endl;
    return 1;
  }
} 